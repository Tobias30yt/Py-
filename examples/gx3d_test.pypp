gfx.window_ratio(1280, 720, 16, 9, "py++ 3D Test")
gfx.keep_aspect(1)
gfx.mouse_lock(1)
gfx.mouse_show(0)

gx3d.reset()
gx3d.fov(430)
gx3d.clip(4, 12000)
gx3d.backface_cull(1)
gx3d.depth_bias(0)
gx3d.camera(0, 0, -700)

let yaw = 0
let pitch = 0
let t = 0

while gfx.closed() == 0:
  gfx.poll()

  if gfx.key_down(27) == 1:
    gfx.mouse_lock(0)
    gfx.mouse_show(1)
    gfx.close()
  end

  # Mouse look
  let yaw = yaw + gfx.mouse_dx() / 2
  let pitch = pitch + gfx.mouse_dy() / 3

  # Keyboard movement
  if gfx.key_down(87) == 1:
    gx3d.camera_move(0, 0, 14)
  end
  if gfx.key_down(83) == 1:
    gx3d.camera_move(0, 0, -14)
  end
  if gfx.key_down(65) == 1:
    gx3d.camera_move(-12, 0, 0)
  end
  if gfx.key_down(68) == 1:
    gx3d.camera_move(12, 0, 0)
  end
  if gfx.key_down(82) == 1:
    gx3d.camera_move(0, 10, 0)
  end
  if gfx.key_down(70) == 1:
    gx3d.camera_move(0, -10, 0)
  end

  let t = t + 2

  gfx.clear(8, 12, 20)
  gx3d.rotate(pitch, yaw, t / 3)
  gx3d.scale_uniform(1000)
  gx3d.translate(0, 0, 0)

  gx3d.grid(2000, 80, -180)
  gx3d.axis(160)

  # Center object cluster
  gx3d.cube_solid(0, 0, 420, 140, 220, 120, 90)
  gx3d.label(0, -110, 420, "CENTER CUBE", 255, 240, 210)
  gx3d.cuboid_solid(-220, -20, 520, 120, 180, 90, 90, 180, 255)
  gx3d.cuboid(220, 10, 520, 140, 100, 200, 255, 210, 110)
  gx3d.triangle_solid(-140, -160, 560, 0, -260, 620, 140, -160, 560, 255, 170, 90)
  gx3d.quad(-360, -100, 640, -220, -40, 640, -200, 80, 640, -380, 60, 640, 120, 255, 180)
  gx3d.quad_solid(180, -80, 640, 340, -30, 640, 320, 110, 640, 160, 70, 640, 255, 120, 90)
  gx3d.pyramid(0, -120, 860, 170, 255, 220, 140)
  gx3d.pyramid_solid(320, -120, 920, 170, 220, 140, 255)
  gx3d.sphere(-320, -120, 920, 90, 18, 140, 220, 255)

  # Extra solids for depth + stability test
  gx3d.cube_solid(0, 200, 700, 180, 140, 180, 255)
  gx3d.cuboid_solid(-280, 180, 760, 120, 160, 90, 255, 160, 120)
  gx3d.cuboid_solid(280, 180, 760, 90, 160, 120, 120, 255, 180)

  if gx3d.world_visible(0, 0, 420) == 1:
    let sx = gx3d.world_to_screen_x(0, 0, 420)
    let sy = gx3d.world_to_screen_y(0, 0, 420)
    gfx.circle(sx, sy, 4, 255, 255, 255)
  end

  # Crosshair
  gfx.line(640 - 10, 360, 640 + 10, 360, 255, 255, 255)
  gfx.line(640, 360 - 10, 640, 360 + 10, 255, 255, 255)

  gfx.present()
  time.sleep_ms(16)
end
