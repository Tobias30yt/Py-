# pong frame renderer for current pypp gfx API

let w = 320
let h = 180
gfx.open(w, h)
gfx.clear(12, 18, 28)

# center line
let y = 0
while y < h:
  let dash = y / 6
  if dash != (dash / 2) * 2:
    gfx.pixel(w / 2, y, 220, 220, 220)
  end
  let y = y + 1
end

# left paddle
let lp_x = 18
let lp_y = 70
let p_h = 38
let p_w = 5
let py = 0
while py < p_h:
  let px = 0
  while px < p_w:
    gfx.pixel(lp_x + px, lp_y + py, 240, 240, 240)
    let px = px + 1
  end
  let py = py + 1
end

# right paddle
let rp_x = w - 23
let rp_y = 82
let py2 = 0
while py2 < p_h:
  let px2 = 0
  while px2 < p_w:
    gfx.pixel(rp_x + px2, rp_y + py2, 240, 240, 240)
    let px2 = px2 + 1
  end
  let py2 = py2 + 1
end

# ball
let bx = 155
let by = 96
let bs = 5
let yy = 0
while yy < bs:
  let xx = 0
  while xx < bs:
    gfx.pixel(bx + xx, by + yy, 255, 255, 255)
    let xx = xx + 1
  end
  let yy = yy + 1
end

# scores as simple blocks: 1 - 0
let sx = 128
let sy = 20
let i = 0
while i < 14:
  gfx.pixel(sx, sy + i, 250, 250, 250)
  let i = i + 1
end

let z_x = 190
let z_y = 20
let zw = 10
let zh = 14
let z1 = 0
while z1 < zw:
  gfx.pixel(z_x + z1, z_y, 250, 250, 250)
  gfx.pixel(z_x + z1, z_y + zh - 1, 250, 250, 250)
  let z1 = z1 + 1
end
let z2 = 0
while z2 < zh:
  gfx.pixel(z_x, z_y + z2, 250, 250, 250)
  gfx.pixel(z_x + zw - 1, z_y + z2, 250, 250, 250)
  let z2 = z2 + 1
end

gfx.save("build/pong_frame.ppm")
print("saved build/pong_frame.ppm")
